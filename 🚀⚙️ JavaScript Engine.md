
![JS engine](https://user-images.githubusercontent.com/93249038/210701264-89555c58-b1f2-4283-b1db-8c1f9353b237.jpg)

JavaScript is cool (don't @ me), but how can a machine actually understand the code you've written? As JavaScript devs, we usually don't have to deal with compilers ourselves. However, it's definitely good to know the basics of the JavaScript engine and see how it handles our human-friendly JS code, and turns it into something machines understand! ü•≥

| Note: This post is mainly based on the V8 engine used by Node.js and Chromium-based browsers.

1) The HTML parser encounters a script tag with a source. Code from this source gets loaded from either the network, cache, or an installed service worker. The response is the requested script as a stream of bytes, which the byte stream decoder takes care of! The byte stream decoder decodes the stream of bytes as it‚Äôs being downloaded.

![1](https://user-images.githubusercontent.com/93249038/210701325-648d31df-d825-4d18-8864-680035fc069b.jpg)

2) The byte stream decoder creates tokens from the decoded stream of bytes. For example, 0066 decodes to f, 0075 to u, 006e to n, 0063 to c, 0074 to t, 0069 to i, 006f to o, and 006e to n followed by a white space. Seems like you wrote function! This is a reserved keyword in JavaScript, a token gets created, and sent to the parser (and pre-parser, which I didn't cover in the gifs but will explain later). The same happens for the rest of the byte stream.

![2](https://user-images.githubusercontent.com/93249038/210701405-84d891bc-7a6d-4d16-8fe3-c888dcc23161.jpg)

3) The engine uses two parsers: the pre-parser, and the parser. In order to reduce the time it takes to load up a website, the engine tries to avoid parsing code that's not necessary right away. The preparser handles code that may be used later on, while the parser handles the code that‚Äôs needed immediately! If a certain function will only get invoked after a user clicks a button, it's not necessary that this code is compiled immediately just to load up a website. If the user eventually ends up clicking the button and requiring that piece of code, it gets sent to the parser.

The parser creates nodes based on the tokens it receives from the byte stream decoder. With these nodes, it creates an Abstract Syntax Tree, or AST. üå≥


![4](https://user-images.githubusercontent.com/93249038/210701465-e35c2908-d992-4da7-844e-ad490ad2867f.jpg)


4) Next, it's time for the interpreter! The interpreter which walks through the AST, and generates byte code based on the information that the AST contains. Once the byte code has been generated fully, the AST is deleted, clearing up memory space. Finally, we have something that a machine can work with! üéâ
![3](https://user-images.githubusercontent.com/93249038/210701558-f544b7ad-7589-4e21-836e-2beeb96e7c5c.jpg)

5) Although byte code is fast, it can be faster. As this bytecode runs, information is being generated. It can detect whether certain behavior happens often, and the types of the data that‚Äôs been used. Maybe you've been invoking a function dozens of times: it's time to optimize this so it'll run even faster! üèÉüèΩ‚Äç‚ôÄÔ∏è

The byte code, together with the generated type feedback, is sent to an optimizing compiler. The optimizing compiler takes the byte code and type feedback, and generates highly optimized machine code from these. üöÄ
![5](https://user-images.githubusercontent.com/93249038/210701614-9a85cae0-b6c9-4d0a-aa39-4cd5a96a2dca.jpg)

JavaScript is a dynamically typed language, meaning that the types of data can change constantly. It would be extremely slow if the JavaScript engine had to check each time which data type a certain value has.

In order to reduce the time it takes to interpret the code, optimized machine code only handles the cases the engine has seen before while running the bytecode. If we repeatedly used a certain piece of code that returned the same data type over and over, the optimized machine code can simply be re-used in order to speed things up. However, since JavaScript is dynamically typed, it can happen that the same piece of code suddenly returns a different type of data. If that happens, the machine code gets de-optimized, and the engine falls back to interpreting the generated byte code.

Say a certain function is invoked a 100 times and has always returned the same value so far. It will assume that it will also return this value the 101st time you invoke it.

Let‚Äôs say that we have the following function sum, that‚Äôs (so far) always been called with numerical values as arguments each time:

![fn sum](https://user-images.githubusercontent.com/93249038/210701700-c1635da5-43f8-4ecf-854e-e1dbb713772b.jpg)
JavaScript is a dynamically typed language, meaning that the types of data can change constantly. It would be extremely slow if the JavaScript engine had to check each time which data type a certain value has.

In order to reduce the time it takes to interpret the code, optimized machine code only handles the cases the engine has seen before while running the bytecode. If we repeatedly used a certain piece of code that returned the same data type over and over, the optimized machine code can simply be re-used in order to speed things up. However, since JavaScript is dynamically typed, it can happen that the same piece of code suddenly returns a different type of data. If that happens, the machine code gets de-optimized, and the engine falls back to interpreting the generated byte code.

Say a certain function is invoked a 100 times and has always returned the same value so far. It will assume that it will also return this value the 101st time you invoke it.

Let‚Äôs say that we have the following function sum, that‚Äôs (so far) always been called with numerical values as arguments each time:

![22](https://user-images.githubusercontent.com/93249038/210701761-336375a4-48ac-4fb2-b3de-e0a7f44056d5.jpg)

This means that the number 2 will get coerced into a string, and the function will return the string "12" instead. It goes back to executing the interpreted bytecode and updates the type feedback.



